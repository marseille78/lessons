# Базовые типы

## Введение

Чтобы программы были полезными, нам нужно иметь возможность работать с некоторыми из самых простых единиц данных: номерами, строками, структурами, логическими значениями и т.п. В TypeScript мы поддерживаем те же типы, что и в JavaScript, с удобным перечислением типов, которые могут быть использованы для поддержки.

## Boolean/Логический

Самый простой тип данных - это простое значение true/false, которое JavaScript и TypeScript вызывают **boolean** значение.

```javascript
let isDone: boolean = false;
```

## Number/Число

Как и в JavaScript, все числа в TypeScript являются значениями с плавающей запятой. Эти числа с плавающей запятой получают тип *number*. В дополнение к шестнадцатеричным и десятичным литералам, TypeScript также поддерживает бинарные и восьмеричные литералы, введенные в ECMAScript 2015.

```javascript
let decimal: number = 6;
let hex: number = 0xf00d;
let binary: number = 0b1010;
let octal: number = 0o744;
```

## String/Строка

Другая фундаментальная часть создания программ в JavaScript для веб-страниц и серверов работает с текстовыми данными. Как и в других языках, мы используем этот тип *string* для обозначения этих текстовых типов данных. Подобно JavaScript, TypeScript также использует двойные кавычки ( **"** ) или одинарные кавычки ( **'** ) для объемных данных.

```javascript
let color: string = "blue";
color = 'red';
```

Вы также можете использовать строки шаблонов , которые могут охватывать несколько строк и иметь встроенные выражения. Эти строки окружены `символом backtick / backquote ( ), а встроенные выражения имеют форму ${ expr }.

let fullName: string = `Bob Bobbington`;
let age: number = 37;
let sentence: string = `Hello, my name is ${ fullName }.

I'll be ${ age + 1 } years old next month.`;
Это эквивалентно объявлению sentence:

let sentence: string = "Hello, my name is " + fullName + ".\n\n" +
    "I'll be " + (age + 1) + " years old next month.";
массив
ТипScript, например JavaScript, позволяет работать с массивами значений. Типы массивов могут быть записаны одним из двух способов. В первом случае вы используете тип элементов, за которыми следует, []чтобы обозначить массив этого типа элемента:

let list: number[] = [1, 2, 3];
Второй способ использует общий тип массива Array<elemType>:

let list: Array<number> = [1, 2, 3];
Кортеж
Типы кортежей позволяют вам выражать массив, в котором известен тип фиксированного числа элементов, но не обязательно должен быть одинаковым. Например, вы можете представить значение как пару a stringи a number:

// Declare a tuple type
let x: [string, number];
// Initialize it
x = ["hello", 10]; // OK
// Initialize it incorrectly
x = [10, "hello"]; // Error
При доступе к элементу с известным индексом извлекается правильный тип:

console.log(x[0].substr(1)); // OK
console.log(x[1].substr(1)); // Error, 'number' does not have 'substr'
При доступе к элементу за пределами набора известных индексов вместо этого используется тип объединения:

x[3] = "world"; // OK, 'string' can be assigned to 'string | number'

console.log(x[5].toString()); // OK, 'string' and 'number' both have 'toString'

x[6] = true; // Error, 'boolean' isn't 'string | number'
Типы соединений - это расширенная тема, которую мы рассмотрим в следующей главе.

Enum
Полезным дополнением к стандартному набору типов данных из JavaScript является enum. Как и в языках типа C #, перечисление - это способ предоставления более дружественных имен наборам числовых значений.

enum Color {Red, Green, Blue}
let c: Color = Color.Green;
По умолчанию, перечисления начинают нумерацию своих членов, начиная с 0. Вы можете изменить это, вручную установив значение одного из своих членов. Например, мы можем начать предыдущий пример 1вместо 0:

enum Color {Red = 1, Green, Blue}
let c: Color = Color.Green;
Или даже вручную задайте все значения в перечислении:

enum Color {Red = 1, Green = 2, Blue = 4}
let c: Color = Color.Green;
Удобной особенностью перечислений является то, что вы также можете перейти от числового значения к имени этого значения в перечислении. Например, если бы мы имели значение, 2но не были уверены, что отображалось в Colorперечислении выше, мы могли бы найти соответствующее имя:

enum Color {Red = 1, Green, Blue}
let colorName: string = Color[2];

alert(colorName); // Displays 'Green' as its value is 2 above
Любые
Нам может понадобиться описать тип переменных, которые мы не знаем при написании приложения. Эти значения могут исходить от динамического содержимого, например, от пользователя или сторонней библиотеки. В этих случаях мы хотим отказаться от проверки типов и позволить значения проходить через проверки времени компиляции. Для этого мы маркируем их anyтипом:

let notSure: any = 4;
notSure = "maybe a string instead";
notSure = false; // okay, definitely a boolean
anyТипом является мощным средством для работы с существующим JavaScript, что позволяет постепенно отказаться в и отказаться от проверки типа во время компиляции. Вы можете рассчитывать Objectна аналогичную роль, как на других языках. Но переменные типа Objectтолько позволяют вам присваивать им какое-либо значение - вы не можете вызывать на них произвольные методы, даже те, которые на самом деле существуют:

let notSure: any = 4;
notSure.ifItExists(); // okay, ifItExists might exist at runtime
notSure.toFixed(); // okay, toFixed exists (but the compiler doesn't check)

let prettySure: Object = 4;
prettySure.toFixed(); // Error: Property 'toFixed' doesn't exist on type 'Object'.
anyТип также удобно , если вы знаете какую - то часть типа, но , возможно , не все. Например, у вас может быть массив, но массив имеет сочетание разных типов:

let list: any[] = [1, true, "free"];

list[1] = 100;
пустота
voidнемного напоминает противоположность any: отсутствие вообще никакого типа. Обычно вы можете рассматривать это как возвращаемый тип функций, которые не возвращают значение:

function warnUser(): void {
    alert("This is my warning message");
}
Объявление переменных типа voidне полезно, потому что вы можете назначать их undefinedили nullим:

let unusable: void = undefined;
Null и Undefined
В TypeScript оба undefinedи на nullсамом деле имеют свои собственные имена undefinedи nullсоответственно. Очень похоже void, что они не очень полезны сами по себе:

// Not much else we can assign to these variables!
let u: undefined = undefined;
let n: null = null;
По умолчанию nullи undefinedявляются подтипами всех других типов. Это означает, что вы можете назначить nullи undefinedчто-то вроде этого number.

Однако при использовании --strictNullChecksфлага nullи undefinedих можно присваивать только voidи их соответствующим типам. Это помогает избежать многих распространенных ошибок. В случаях, когда вы хотите передать либо a, stringлибо nullили undefined, вы можете использовать тип объединения string | null | undefined. Еще раз, больше о типах союзов позже.

В качестве примечания: мы рекомендуем использовать, --strictNullChecksкогда это возможно, но для целей настоящего руководства мы предположим, что он отключен.

Никогда
neverТип представляет собой тип значений , которые никогда не встречаются. Например, neverэто тип возврата для выражения функции или выражения функции стрелки, которое всегда выдает исключение или никогда не возвращается; Переменные также приобретают тип neverпри сужении любого типа охранников, который никогда не может быть правдой.

neverТип является подтипом, и, присваиваемые каждому типу; однако ни один тип не является подтипом или не может быть присвоен never(кроме neverсамого себя). Даже anyне поддается never.

Некоторые примеры возвращаемых функций never:

// Function returning never must have unreachable end point
function error(message: string): never {
    throw new Error(message);
}

// Inferred return type is never
function fail() {
    return error("Something failed");
}

// Function returning never must have unreachable end point
function infiniteLoop(): never {
    while (true) {
    }
}
Утверждения типа
Иногда вы окажетесь в ситуации, когда вы будете знать больше о значении, чем это делает TypeScript. Обычно это происходит, когда вы знаете, что тип какого-либо объекта может быть более конкретным, чем его текущий тип.

Утверждения типа - это способ сказать компилятору «доверься мне, я знаю, что я делаю». Утверждение типа похоже на тип, применяемый на других языках, но не выполняет никакой специальной проверки или реструктуризации данных. Он не имеет эффекта runtime и используется исключительно компилятором. TypeScript предполагает, что вы, программист, выполнили любые специальные проверки, которые вам нужны.

Утверждения типа имеют две формы. Один из них - синтаксис «угол-скобка»:

let someValue: any = "this is a string";

let strLength: number = (<string>someValue).length;
А другой - as-syntax:

let someValue: any = "this is a string";

let strLength: number = (someValue as string).length;
Два образца эквивалентны. Использование одного над другим - это в основном выбор предпочтений; однако при использовании TypeScript с JSX asдопускаются только утверждения в стиле.

Заметка о let
Вы, возможно, заметили, что до сих пор мы использовали letключевое слово вместо ключевого слова JavaScript, с varкоторым вы могли бы лучше ознакомиться. letКлючевое слово на самом деле новый JavaScript построить что машинопись делает доступной. Мы обсудим детали позже, но многие распространенные проблемы в JavaScript облегчаются с помощью let, поэтому вы должны использовать его, а не varкогда это возможно.